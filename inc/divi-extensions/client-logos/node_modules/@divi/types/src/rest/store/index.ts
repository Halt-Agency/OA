import {
  type ImmutableArray,
  type ImmutableObject,
} from 'seamless-immutable';

import { type PostStatus } from '@divi/types-external';

import { type BatchLog } from '../batch-log';
import { type Log } from '../log';


export namespace Store {
  export interface State {

    // Read-only.
    readonly url: string;

    // Writable.
    // TODO This needs to be refactored because it possibly causes confusion.
    log: Actions.AddLog.Item[];
    logs: Log.Item[];
    batchLogs: BatchLog.Item[];
    inProgress: Record<string, boolean>;
  };

  export type ImmutableState = ImmutableObject<State>;

  export interface Instance {
    dispatch: () => void;
    getState: () => ImmutableState;
  };

  export namespace Actions {
    export namespace AddLog {

      /**
       * Log item request data.
       *
       * @since ??
       */
      export type ItemRequestData = unknown;

      /**
       * Log item response data.
       *
       * @since ??
       */
      export interface ItemResponseData {
        status: 'success' | 'fail';
        data: unknown;
      }

      /**
       * Add log Ajax request action interface.
       *
       * @since ??
       */
      export interface ReturnValue {
        type: 'ADD_LOG';

        /**
         * Ajax action name.
         */
        ajaxAction: string;

        /**
         * Data to be sent to the server.
         */
        requestData: ItemRequestData;

        /**
         * The data returned from the server.
         */
        responseData: ItemResponseData;
      }

      /**
       * Log item.
       *
       * @since ??
       */
      export type Item = Omit<ReturnValue, 'type'> & {
        timestamp: number;
      }
    }

    export namespace ResetState {
      export type ReturnValue = {
        type: 'RESET_STATE';
      }
    }

    export namespace SetBatchLog {
      export type ReturnValue<TBatchLogStatus> = {
        type: 'SET_BATCH_LOG';
        id: string;
        route: string;
        data: unknown[];
        status: TBatchLogStatus;
      }
    }

    export namespace SetInProgress {
      export type ReturnValue = {
        type: 'SET_ON_PROGRESS';
        ajaxAction: string;
        isInProgress: boolean;
      }
    }

    export namespace SetLog {
      export type ReturnValue<TLogResponse, TLogStatus> = {
        type: 'SET_LOG';
        route: string;
        data: unknown;
        response: TLogResponse;
        status: TLogStatus;
        batchId: string;
      }
    }

    export namespace SyncToServer {

      /**
       * Sync to server action interface.
       *
       * @since ??
       */
      export type ReturnValue = {
        type: 'SYNC_TO_SERVER';
        postStatus?: PostStatus;
      }

      /**
       * Sync to server function params.
       *
       * @since ??
       */
      export type Params = Omit<ReturnValue, 'type'>;
    }

    export namespace UpdateBatchLog {
      export type ReturnValue<TBatchLogStatus> = {
        type: 'UPDATE_BATCH_LOG';
        id: string;
        route: string;
        data: unknown[];
        status: TBatchLogStatus;
      }
    }

    export namespace UpdateLog {
      export type ReturnValue<TLogResponse, TLogStatus> = {
        type: 'UPDATE_LOG';
        route: string;
        data: unknown;
        response: TLogResponse;
        status: TLogStatus;
        batchId: string;
      }

    }

    export type FunctionMap = {
      addLog: (
        ajaxAction: string,
        requestData: AddLog.ItemRequestData,
        responseData: AddLog.ItemResponseData,
      ) => ReturnValue,
      resetState: () => ResetState.ReturnValue,
      setBatchLog: (
        id: string,
        route: string,
        data: unknown[],
        status: Log.Status,
      ) => SetBatchLog.ReturnValue<Log.Status>,
      setInProgress: (
        ajaxAction: string,
        isInProgress: boolean,
      ) => SetInProgress.ReturnValue,
      setLog: (
        route: string,
        data: unknown,
        response: Log.Response,
        status: Log.Status,
        batchId?: string,
      ) => SetLog.ReturnValue<Log.Response, Log.Status>,
      syncToServer: (
        params: SyncToServer.Params,
      ) => SyncToServer.ReturnValue,
      updateBatchLog: (
        id: string,
        route: string,
        data: unknown[],
        status: Log.Status,
      ) => UpdateBatchLog.ReturnValue<Log.Status>,
      updateLog: (
        route: string,
        data: unknown,
        response: Log.Response,
        status: Log.Status,
        batchId?: string,
      ) => UpdateLog.ReturnValue<Log.Response, Log.Status>,
    };

    export type ReturnValue =
      AddLog.ReturnValue |
      ResetState.ReturnValue |
      SetBatchLog.ReturnValue<Log.Status> |
      SetInProgress.ReturnValue |
      SetLog.ReturnValue<Log.Response, Log.Status> |
      SyncToServer.ReturnValue |
      UpdateBatchLog.ReturnValue<Log.Status> |
      UpdateLog.ReturnValue<Log.Response, Log.Status>;
  };

  export namespace Selectors {
    export type FunctionMap = {
      getLastLog: (
        route?: string,
        data?: unknown,
        status?: Log.Status,
        batchId?: string,
      ) => Log.Item,
      getLog: (
        ajaxAction?: string,
      ) => ImmutableArray<Actions.AddLog.Item>,
      getLogs: (
        route?: string,
        data?: unknown,
        status?: Log.Status,
        batchId?: string,
      ) => ImmutableArray<Log.Item>,
      getUrl: () => string,
      isInProgress: (
        ajaxAction?: string | string[],
      ) => boolean,
    }
  }
}
