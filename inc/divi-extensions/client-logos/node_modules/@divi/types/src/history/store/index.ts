import { type ImmutableObject } from 'seamless-immutable';

import { type Events } from '../../events';
import { type SerializedPost } from '../../serialized-post';


export namespace Store {
  export interface Item {
    actionType: string;
    payload: Actions.Add.Payload;
    trigger: string;
  }

  export interface State {
    'edit-post': Array<Item>;
    'events': Array<Item>;
  };

  export type ImmutableState = ImmutableObject<State>;

  export interface Instance {
    dispatch: () => void;
    getState: () => ImmutableState;
  };

  export namespace Actions {
    export namespace Add {

      /**
       * Payload are based on various interface so use Intersection Types to combine multiple interfaces
       * into a type; This means when those interface are updated, this type is automatically adjusted.
       *
       * @see {@link https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html#intersection-types}
       * regarding how Intersection Types works.
       *
       * @todo Adjust this on history foundation.
       */
      export type Payload =
        SerializedPost.Store.ImmutableState |
        Events.Store.Log.Payload |
        {
          label?: string,
          details?: string,
        };

      export type ReturnValue = {
        type: 'ADD';
        category: string;
        actionType: string;
        trigger: string;
        payload: Payload;
      }
    }

    export type FunctionMap = {
      add: (
        category: string,
        actionType: string,
        trigger: string,
        payload: Add.Payload,
      ) => Add.ReturnValue;
    };

    export type ReturnValue = Add.ReturnValue;
  };

  export namespace Selectors {
    export type FunctionMap = {
      allState: () => ImmutableState;
      getRecentSubHistory: (
        category: string,
        max?: number
      ) => Item[];
      getSubHistory: (
        category: string,
        defaultValue?: any,
      ) => Item[],
    }
  }
}
