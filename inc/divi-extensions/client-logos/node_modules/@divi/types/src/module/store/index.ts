import { type ImmutableObject } from 'seamless-immutable';

import { InlineEditor as InlineEditorNamespace } from './inline-editor';
import { Parallax as ParallaxNamespace } from './parallax';
import { Sticky as StickyNamespace } from './sticky';


export namespace Store {
  /* eslint-disable @typescript-eslint/no-unused-vars */
  // TODO figure out a way to declare nested namespace without disabling no-unused-vars rule
  // imported namespace as marked as unused by eslint using this config; it shouldn't happen in the first place.
  export import InlineEditor = InlineEditorNamespace;
  export import Parallax = ParallaxNamespace;
  export import Sticky = StickyNamespace;
  /* eslint-enable @typescript-eslint/no-unused-vars */

  export interface State {
    scripts?: {
      sticky?: Record<string, StickyNamespace.Setting>;
      parallax?: Record<string, ParallaxNamespace.Setting>;
    };
    inlineEditorClick?: boolean;
    inlineEditorToolbar?: InlineEditorNamespace.Toolbar;
  };

  export type ScriptName = keyof State['scripts'];

  export type ImmutableState = ImmutableObject<State>;

  export interface Instance {
    dispatch: () => void;
    getState: () => any;
  };

  export namespace Actions {

    export namespace SetInlineEditorClick {
      export type Params = Omit<ReturnValue, 'type'>;

      export type ReturnValue = {
        type: 'SET_INLINE_EDITOR_CLICK';
        isInlineEditorClick: boolean;
      }
    }

    export namespace SetInlineEditorToolbar {
      export type Params = Omit<ReturnValue, 'type'>;

      export type ReturnValue = {
        type: 'SET_INLINE_EDITOR_TOOLBAR';
        payload: InlineEditorNamespace.Toolbar;
        clickInside: boolean,
        clickOutside: boolean,
      }
    }

    export namespace SetScriptItem {
      export type Params = Omit<ReturnValue, 'type'>;

      export type ReturnValue = {
        type: 'SET_SCRIPT_ITEM';
        id: string;
      } & (
          {
            scriptName: 'sticky'
            item: StickyNamespace.Setting;
          } |
          {
            scriptName: 'parallax'
            item: ParallaxNamespace.Setting;
          }
        )
    }

    export namespace UnsetScriptItem {
      export type Params = Omit<ReturnValue, 'type'>;

      export type ReturnValue = {
        type: 'UNSET_SCRIPT_ITEM';
        id: string;
      } & (
          {
            scriptName: 'sticky';
            item?: unknown;
          } | {
            scriptName: 'parallax';
            item?: ParallaxNamespace.Setting;
          }
        )
    }

    export type FunctionMap = {
      setInlineEditorClick: (params: SetInlineEditorClick.Params) => SetInlineEditorClick.ReturnValue;
      setInlineEditorToolbar: (params: SetInlineEditorToolbar.Params) => SetInlineEditorToolbar.ReturnValue;
      setScriptItem: (params: SetScriptItem.Params) => SetScriptItem.ReturnValue;
      unsetScriptItem: (params: UnsetScriptItem.Params) => UnsetScriptItem.ReturnValue;
    };

    export type ReturnValue =
      SetInlineEditorClick.ReturnValue |
      SetInlineEditorToolbar.ReturnValue |
      SetScriptItem.ReturnValue |
      UnsetScriptItem.ReturnValue;
  };

  export namespace Selectors {
    export type FunctionMap = {
      getInlineEditorClick: () => ImmutableState['inlineEditorClick'];
      getInlineEditorToolbar: () => ImmutableState['inlineEditorToolbar'];
      getScriptItem: (
        scriptName: ScriptName,
        id: string,
      ) => ImmutableState['scripts'][ScriptName][keyof ImmutableState['scripts'][ScriptName]]
      getScripts: () => ImmutableState['scripts'];
    }
  }
}
