import { type OnOff } from '../../../attr';
import { type FormatBreakpointStateAttr } from '../../../format-attr';
import { type Element } from '../../element';

// TODO maybe refactor this; make focus and placeholder as state (value|hover|sticky|focus).
// Field Element Attribute here is tricky because technically both `focus` and `placeholder`
// can / should be handled as state along with `value`, `hover`, and `sticky`. That being said
// we have no such state so the best thing that we can do is to keep `options` as aligned to
// Element.Decoration.Attributes and set focus and placeholder attributes on `parts`. Ideally, at some point
// both focus and placeholder is handled as official state so that both of them don't need
// to be declared at `parts`.
// Here's a problem with having `focus` (or placeholder) not being handled as a state: is there
// hover-style for focused field?
export interface FieldElementAttr {
  decoration?: Element.Decoration.PickedAttributes<'background' | 'border' | 'boxShadow' | 'font' | 'spacing'>;
  advanced?: {
    focusUseBorder?: FormatBreakpointStateAttr<OnOff>;
    focus?: Element.Decoration.PickedAttributes<'background' | 'border' | 'font'>;
    placeholder?: Element.Decoration.PickedAttributes<'font'>;
  }
}
