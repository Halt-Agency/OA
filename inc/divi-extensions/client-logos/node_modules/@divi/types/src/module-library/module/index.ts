import { type ReactElement } from 'react';

import {
  type BlockConfiguration,
  type BlockInstance,
} from '@wordpress/blocks';

import { type ModuleConversionOutline } from '../../conversion';
import {
  type Module as ModulePackage,
  type ModuleAttrs,
  type ModuleDefinitionAttributeType,
  type ModuleMetadata,
} from '../../module';
import {
  type ModuleFlatObject,
} from '../../module/state';
import {
  type KeysOfUnion,
} from '../../utils';


export namespace Module {

  export type Category = 'structure' | 'fullwidth-module' | 'module' | 'child-module' | 'unsupported';

  export type Collections = Record<string, Settings>;

  /**
  * Attribute interface of module definition's attribute.
  *
  * NOTE: This is based off Gutenberg's block definition. We may or may not use this later since
  * Visual Builder module attribute is defined by its fields.
  *
  * @since ??
  */
  export type Attribute = {
    type?: ModuleDefinitionAttributeType;
  }

  /**
  * Module attributes definition.
  *
  * @since ??
  */
  export type Attributes<TAttrs = ModuleAttrs> = Record<KeysOfUnion<TAttrs>, Attribute>;

  /**
  * Module that gets added as part of template when module is added.
  *
  * @since ??
  */
  export type Template<TChildModuleAttrs = ModuleAttrs> = (string | TChildModuleAttrs)[];

  /**
  * Templates of module attributes that gets inserted when module is added.
  *
  * @since ??
  */
  export type Templates<TChildModuleAttrs = ModuleAttrs> = Template<TChildModuleAttrs>[];

  /**
  * Module renderers interface.
  *
  * @since ??
  */
  export type Renderers<TAttrs> = {
    edit: (props: Component.EditProps<TAttrs>) => ReactElement;
    wireframe?: (props: ModulePackage.ModuleContainerProps<TAttrs>) => ReactElement;

    // Preset prototype.
    // TODO: Need to be set as required once all modules have this.
    styles?: (props: ModulePackage.StylesProps<TAttrs>) => ReactElement;
  }

  /**
  * Settings interface of Module definitions.
  *
  * @since ??
  */
  export interface Settings<
    TAttrs = ModuleAttrs,
    TChildModuleAttrs = ModuleAttrs
  > extends BlockConfiguration {
    titles: string;
    placeholderContent?: TAttrs;
    defaultAttrs?: TAttrs;
    defaultPrintedStyleAttrs?: TAttrs;
    defaultSettingsAttrs?: TAttrs;
    settings?: {
      content?: (props: ModulePackage.SettingsProps) => ReactElement,
      design?: (props: ModulePackage.SettingsProps) => ReactElement,
      advanced?: (props: ModulePackage.SettingsProps) => ReactElement,
    };
    template?: Templates<TChildModuleAttrs>;
    parentsName?: string[];
    childrenName?: string[];
    supportChildObjects?: boolean;
    folder?: string;

    attributes: Partial<Attributes<TAttrs>>;

    // Can't use `icon` because it has been used by `BlockConfiguration`.
    // @todo reconsider to completely drop block definition for module declaration.
    moduleIcon?: string;

    edit?: never; // Drop the usage edit property. Use the renderers.edit property instead.

    save?: never; // Drop the usage save property. Use the renderers.save property instead.

    renderers: Renderers<TAttrs>;

    d4Shortcode?: string;
    official: boolean;
    conversionOutline?: ModuleConversionOutline;

    credit?: {
      author?: string,
      authorURI?: string,
      moduleURI?: string,
    }

    moduleClassName?: string;
    moduleOrderClassName?: string;

    /**
     * TODO(D5, Types): Replace `string` with module library name type (eg. `divi/counter` | `divi/accordion-item`).
     *
     * How `childModuleName` differs from `ModuleRegisterDefinition['childrenName]`: The type for
     * ``ModuleRegisterDefinition['childrenName]` is `string[]` which implies that a module can have
     * multiple possible type of child module. This was added assuming in D6 a module can have multiple
     * type of modules inside of it (container module have two different kind of modules, etc). In
     * `Metadata.Values['childModuleName']`, the type is set into `string` because this is used
     * by `getAutoGenerateModuleSettingsPanel()` to automatically added `<DraggableChildModuleListContainer />`
     * into auto generate content panel. In this case, at least right now `<DraggableChildModuleListContainer />`
     * can only have one type of child module thus the value of `childModuleName` is set into `string`.
     */
    childModuleName?: string;
    childModuleTitle?: string;
    childModuleTitleAttribute?: string;
  }

  /**
  * Module definition interface.
  *
  * @since ??
  */
  export type Definition<TAttrs = ModuleAttrs, TChildModuleAttrs = ModuleAttrs> = {
    name: string;
    settings: Settings<TAttrs, TChildModuleAttrs>;
  }

  export type RegisterDefinition<TAttrs = ModuleAttrs, TChildModuleAttrs = ModuleAttrs> = {

    /**
    * `ModuleMetadata` cannot accept `ModuleAttrs` union type because `ModuleAttrs` does not actually contain
    * all modules' attribute keys. Therefore we use a conditional type:
    * if `ModuleAttrs`is provided, we default to `DefaultModuleAttributes`, otherwise we use the passed generic.
    */
    metadata: ModuleMetadata<TAttrs extends ModuleAttrs ? ModulePackage.Default.Attributes : TAttrs>;
    settings?: {
      content?: (props: ModulePackage.SettingsProps) => ReactElement,
      design?: (props: ModulePackage.SettingsProps) => ReactElement,
      advanced?: (props: ModulePackage.SettingsProps) => ReactElement,
    };
    template?: Templates<TChildModuleAttrs>;
    placeholderContent?: TAttrs;
    parentsName?: string[];
    childrenName?: string[];
    supportChildObjects?: boolean;
    renderers: Renderers<TAttrs>;
    conversionOutline?: ModuleConversionOutline;
  }

  export namespace Component {

    /**
    * Interface for module instance.
    *
    * This interface extending BlockInstance interface to have the proper innerBlocks property
    * type declaration when doing serialization.
    *
    * @since ??
    */
    export interface Instance<TAttrs> extends BlockInstance<TAttrs> {
      innerBlocks: Instance<TAttrs>[];
    }

    /**
    * Component props of module that is rendered on visual builder' app.
    *
    * @since ??
    */
    export interface EditProps<
      TAttrs,
      TParentAttrs = unknown,
      TChildAttrs = unknown
    > extends ModulePackage.ModuleBaseProps<TAttrs, TParentAttrs> {
      attrs: TAttrs;
      defaultPrintedStyleAttrs?: TAttrs;
      childModules?: ModuleFlatObject<TChildAttrs>[];
      isFirst?: boolean;
      moduleOrderIndex?: number;

      // Params can be anything at this moment, hence unknown.
      // TODO feat(Refactor) Provide stricter type / interface
      parentCallback?: (params?: unknown) => void;
      parentName?: string;
      parentAttrs?: TParentAttrs;
      parentDefaultAttrs?: TParentAttrs;
      siblingAttrs?: {
        previous?: TAttrs;
        next?: TAttrs;
      }
      pageSettings?: {
        sectionBackgroundColor?: string,
      },
      elements?: ModulePackage.ModuleElements;
    }

    /**
    * Component props as extra props that will be injected into
    * component save function attributes when serializing the post content.
    *
    * @since ??
    */
    export type SerializerProps<TAttrs> = {
      childrenIds: string[],
      hasModule: boolean;
      id: string;
      innerBlocks: Instance<SerializerAttrs<TAttrs>>[];
      isLast: boolean;
      isFirst: boolean;
      moduleIndex: number;
      parentModuleIndex?: number;
      name: string;
    }

    /**
    * Interface for module attributes in serializer context.
    *
    * @since ??
    */
    export type SerializerAttrs<TAttrs> = TAttrs & {
      serializerProps: SerializerProps<TAttrs>;
    }
  }
}
